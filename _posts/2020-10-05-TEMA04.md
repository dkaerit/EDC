--- 
layout: post
---
<div class="header">
  <div class="numbrerUnit">4</div>
  <h1>Estructura de una ALU de enteros.</h1>
  <subtitle>Repaso de las operaciones principales con enteros</subtitle>
</div>

(55 páginas)

## 1. Introducción 
La ALU es definida por las siguientes características:
- Operaciones de enteros: Trabaja principalmente para funciones enteras, principalmente sumas y restas. Las opraciones en punto flotante van en una unidad aparte.
- Aritmética finita: Su aritmética es finita. (ej, sumar 2 números de n bits como mucho el resultado será n+1. En el caso de una multiplicación es 2n)

### 1.1 Representación numérica
- Maxiam precisión de los enteros: la unidad
- Rango: 
  - Binario puro `[0, 2ⁿ⁻¹]`
  - Signo-magnitud `[-(2ⁿ⁻¹-1), 2^ⁿ⁻¹-1]` el primer bit indica el signo y el resto el número. Hay 2 ceros. Problema: Hay varias codificaciones para el 0/1, pueden significar el numero o pueden significar el signo.
  - Compelmento a 1 `[-(2ⁿ⁻¹-1), 2^ⁿ⁻¹-1]` los negativos es la inversión de bits del positivo. Hay dos ceros y sigue arrastrando el problema de signo-magnitud.
  - Complemento a 2 `[-(2ⁿ⁻¹), 2^ⁿ⁻¹-1]` cpl1+1. Problema: No es simétrico
 
### 1.1. Representación numérica 

> **Entonces si**<br>
> **1001** en binario puero es **9**<br>
> **1001** en signo-magnitud es **-1**<br>
> **1001** en cpl1 es **-6**<br>
> **1001** en cpl2 es **-7**<br>
> **¿Qué número es 1001?**<br>
>
> Depende de la codificción
>

## 2. Flags
  - zero: Se pone a 1 si el resultado fue 0
  - carry: Es el bit que no cabe en una suma de enteros sin signo
  - overflow: Lo mismo que el carry pero sirve para numeros con signo (cuando no coinciden los signos de los operandos con el bit de signo que sale)
  - parity: Se pone a 1 si hay el mismo número de 1s que de 0s
  - sign: Se pone a 1 si es negativo 

## 3. Operaciones básicas
- Circuito combinacional
  - Tiene una salida y que depende de una entrada x
  - No tiene memoria y mantiene la salida mientras se mantengan las entradas
  - Tiene un retardo que es el tiempo de propagación
- Circuito secuencial
  - Tiene estados (fases/etapas)
  - Son controlados por un reloj y requieren de elementos de memoria que guarden el estado.

### 3.1. Elementos básicos
- Semisumador (Half-Adder)

```print
input  a,b
output s,cout

xor(a,b; s)
and(a,b; cout)
```

No sirve para hacer operaciones de más de un bit porque no dispone de un cin.

- Sumadores (Full adder)

```print
input  a,b,cin
output s,cout
middle w1,w2,w3
middle s1,co1,s2,co2

--- Con puertas básicas ---
xor(a,b; w1)
and(a,b; w2)
and(w1,cin; w3)

xor(w1,cin; s)
or(w2,w3; cout)

--- Con modulos ---
ha1(a,b; s1,co1)
ha2(cin,s1; s,co2)
or(co1,co2; cout)
```

Se resume en: Hay acarreo si

```print
  (a&b) = 1
  (a|b) = 1 & cin = 1
```

### 3.2. RCA (4 bits)
El camino crítico es el peor tiempo posible. El camino más largo, el amino por el que más puertas hay que pasar.
por ejemplo, en el full-adder el camino crítico sería de 3 puertas.
En el caso del RCA sería 9 puertas: Las 3 primeras para llegar al cout, y a partir de ahi en el siguiente fa, son dos hasta el ultimo.

### 3.3. CSA
No da directamente el resultado de la suma, habría que conectar a sus salidas un RCA.

### 3.3. CPA
A cada FA se le añade dos señales adicionales

```print
  (propagación) pᵢ = aᵢ | bᵢ # si potencialmente puedo tener acarreo
  (generacion) gᵢ = aᵢ & bᵢ
  (acarreo) cᵢ₊₁ = gᵢ | (pᵢ & Cᵢ)
```

Su camino crítico es de dos niveles.

## 4. Multiplicación combinacional
lorem ipsum
### 4.1. Sin signo
#### 4.1.1. Árbol de Wallace

## 5. Multiplicación secuaencial
lorem ipsum
### 5.1. Lápiz y papel
### 5.2. Robertson
### 5.3. Booth
### 5.4. Booth (2 bits)

## 6. División
lorem ipsum

### 6.1. División con restauración

### 6.2. División sin restauración
